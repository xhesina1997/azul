import { Component, ElementRef, ViewEncapsulation, EventEmitter, NgZone, Input, NgModule } from '@angular/core';
import { create, supported } from 'filepond';
export { registerPlugin } from 'filepond';
import { CommonModule } from '@angular/common';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
// We test if filepond is supported on the current client
const isSupported = supported();
// List of attributes for fallback input
const inputAttributes = [
    'id',
    'name',
    'class',
    'multiple',
    'required',
    'disabled',
    'capture',
    'accept'
];
// Methods not made available on the component
const filteredComponentMethods = [
    'setOptions',
    'on',
    'off',
    'onOnce',
    'appendTo',
    'insertAfter',
    'insertBefore',
    'isAttachedTo',
    'replaceElement',
    'restoreElement',
    'destroy'
];
const outputs = [
    'oninit',
    'onwarning',
    'onerror',
    'onactivatefile',
    'onaddfilestart',
    'onaddfileprogress',
    'onaddfile',
    'onprocessfilestart',
    'onprocessfileprogress',
    'onprocessfileabort',
    'onprocessfilerevert',
    'onprocessfile',
    'onprocessfiles',
    'onremovefile',
    'onpreparefile',
    'onupdatefiles'
];
class FilePondComponent {
    /**
     * @param {?} root
     * @param {?} zone
     */
    constructor(root, zone) {
        this.options = {};
        this.handleEvent = null;
        this.root = root;
        this.zone = zone;
        outputs.forEach(output => {
            this[output] = new EventEmitter();
        });
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        const /** @type {?} */ input = this.root.nativeElement.querySelector('input');
        // transfer relevant attributes to input, this so we still have an input with the correct attributes should file pond not load
        const /** @type {?} */ attributes = this.root.nativeElement.attributes;
        inputAttributes.forEach(name => {
            const /** @type {?} */ value = attributes[name] ? attributes[name].value : this.options[name];
            if (!value) {
                return;
            }
            input.setAttribute(name, value);
        });
        // no sufficient features supported in this browser
        if (!isSupported) {
            return;
        }
        // map FilePond events to Angular $emitters
        this.handleEvent = (e) => {
            this[`on${e.type.split(':')[1]}`].emit(Object.assign({}, e.detail));
        };
        outputs.forEach(event => {
            this.root.nativeElement.addEventListener(`FilePond:${event.substr(2)}`, this.handleEvent);
        });
        // will block angular from listening to events inside the pond
        this.zone.runOutsideAngular(() => {
            // create instance
            this.pond = create(input, Object.assign({}, this.options, { files: this.files }));
        });
        // Copy instance method references to component instance
        Object.keys(this.pond)
            .filter(key => filteredComponentMethods.indexOf(key) === -1)
            .forEach(key => {
            this[key] = this.pond[key];
        });
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        // no need to handle first change
        if (changes["firstChange"]) {
            return;
        }
        
        // no filepond instance available
        if (!this.pond) {
            return;
        }
        // use new options object as base ( or if not available, use current options )
        const /** @type {?} */ options = changes["options"] ? changes["options"].currentValue : this.options;
        // see if file list has changed
        if (changes["files"] && JSON.stringify(changes["files"].previousValue) !== JSON.stringify(changes["files"].currentValue)) {
            // file list has changed
            options.files = changes["files"].currentValue;
        }
        // set new options
        this.pond.setOptions(options);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (!this.pond) {
            return;
        }
        outputs.forEach(event => {
            this.root.nativeElement.removeEventListener(`FilePond:${event.substr(2)}`, this.handleEvent);
        });
        this.pond.destroy();
    }
}
FilePondComponent.decorators = [
    { type: Component, args: [{
                selector: 'file-pond',
                encapsulation: ViewEncapsulation.None,
                template: `<div class="filepond--wrapper">
  <input type="file"/>
</div>`,
                styles: [``],
                outputs
            },] },
];
/** @nocollapse */
FilePondComponent.ctorParameters = () => [
    { type: ElementRef, },
    { type: NgZone, },
];
FilePondComponent.propDecorators = {
    "options": [{ type: Input },],
    "files": [{ type: Input },],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class FilePondModule {
}
FilePondModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule
                ],
                declarations: [FilePondComponent],
                exports: [
                    FilePondComponent
                ]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Generated bundle index. Do not edit.
 */

export { FilePondModule, FilePondComponent as Éµa };
//# sourceMappingURL=ngx-filepond.js.map
